import { connectToDatabase } from '../mongodb';
import { VulnerabilityPattern } from '../database/audit-models';

export class VulnerabilityDatabase {
  private static instance: VulnerabilityDatabase;
  private patterns: Map<string, VulnerabilityPattern> = new Map();
  private lastUpdated: Date = new Date(0);

  static getInstance(): VulnerabilityDatabase {
    if (!VulnerabilityDatabase.instance) {
      VulnerabilityDatabase.instance = new VulnerabilityDatabase();
    }
    return VulnerabilityDatabase.instance;
  }

  async initializePatterns(): Promise<void> {
    const defaultPatterns: Omit<VulnerabilityPattern, '_id'>[] = [
      {
        patternId: 'rust-integer-overflow',
        name: 'Integer Overflow in Rust',
        description: 'Potential integer overflow in arithmetic operations without overflow checks',
        severity: 'high',
        category: 'Arithmetic',
        language: ['rust'],
        regex: '\\b\\w+\\s*[+\\-*/]\\s*\\w+(?!.*(?:checked_|wrapping_|saturating_))',
        falsePositiveRate: 0.3,
        confidenceScore: 0.7,
        cwe: 'CWE-190',
        references: ['https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow'],
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      },
      {
        patternId: 'solana-missing-signer-check',
        name: 'Missing Signer Check in Solana',
        description: 'Function modifies state without proper signer verification',
        severity: 'critical',
        category: 'Access Control',
        language: ['rust'],
        regex: 'pub\\s+fn\\s+\\w+.*\\(.*ctx:\\s*Context<\\w+>.*\\).*\\{[^}]*(?:ctx\\.accounts\\.\\w+\\.\\w+\\s*=|\\*\\*ctx\\.accounts)(?![^}]*(?:is_signer|Signer))',
        falsePositiveRate: 0.2,
        confidenceScore: 0.9,
        cwe: 'CWE-284',
        references: ['https://docs.solana.com/developing/programming-model/calling-between-programs'],
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      },
      {
        patternId: 'move-unvalidated-move-from',
        name: 'Unvalidated move_from in Move',
        description: 'Resource moved without proper validation checks',
        severity: 'high',
        category: 'Resource Management',
        language: ['move'],
        regex: 'move_from(?!.*(?:assert|require|exists))',
        falsePositiveRate: 0.4,
        confidenceScore: 0.6,
        cwe: 'CWE-20',
        references: ['https://move-language.github.io/move/'],
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      },
      {
        patternId: 'cairo-missing-range-check',
        name: 'Missing Range Check in Cairo',
        description: 'Input values not validated for proper range',
        severity: 'medium',
        category: 'Input Validation',
        language: ['cairo'],
        regex: 'func\\s+\\w+\\([^)]*felt[^)]*\\)(?![^{]*(?:assert|require|range_check))',
        falsePositiveRate: 0.5,
        confidenceScore: 0.5,
        cwe: 'CWE-20',
        references: ['https://cairo-lang.org/docs/'],
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      },
      {
        patternId: 'reentrancy-pattern',
        name: 'Reentrancy Vulnerability',
        description: 'External call followed by state change',
        severity: 'critical',
        category: 'Reentrancy',
        language: ['rust', 'move', 'cairo'],
        regex: '(?:invoke|call|transfer).*\\([^)]*\\).*\\n[^\\n]*(?:=|move_to|storage_write)',
        falsePositiveRate: 0.3,
        confidenceScore: 0.8,
        cwe: 'CWE-367',
        references: ['https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/'],
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      },
      {
        patternId: 'unchecked-return-value',
        name: 'Unchecked Return Value',
        description: 'Function call return value not checked for errors',
        severity: 'medium',
        category: 'Error Handling',
        language: ['rust', 'move'],
        regex: '(?:transfer|send|call|invoke)\\s*\\([^)]*\\)\\s*;',
        falsePositiveRate: 0.4,
        confidenceScore: 0.6,
        cwe: 'CWE-252',
        references: ['https://swcregistry.io/docs/SWC-104'],
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      }
    ];

    const { db } = await connectToDatabase();
    const patternsCollection = db.collection<VulnerabilityPattern>('vulnerability_patterns');

    // Check if patterns already exist
    const existingCount = await patternsCollection.countDocuments();
    if (existingCount === 0) {
      await patternsCollection.insertMany(defaultPatterns);
      console.log(`Initialized ${defaultPatterns.length} vulnerability patterns`);
    }

    await this.loadPatterns();
  }

  async loadPatterns(): Promise<void> {
    const { db } = await connectToDatabase();
    const patterns = await db.collection<VulnerabilityPattern>('vulnerability_patterns')
      .find({ isActive: true })
      .toArray();

    this.patterns.clear();
    for (const pattern of patterns) {
      this.patterns.set(pattern.patternId, pattern);
    }

    this.lastUpdated = new Date();
    console.log(`Loaded ${patterns.length} vulnerability patterns`);
  }

  async getPatternsByLanguage(language: string): Promise<VulnerabilityPattern[]> {
    if (Date.now() - this.lastUpdated.getTime() > 5 * 60 * 1000) { // Refresh every 5 minutes
      await this.loadPatterns();
    }

    return Array.from(this.patterns.values()).filter(pattern => 
      pattern.language.includes(language.toLowerCase())
    );
  }

  async addPattern(pattern: Omit<VulnerabilityPattern, '_id'>): Promise<string> {
    const { db } = await connectToDatabase();
    const result = await db.collection<VulnerabilityPattern>('vulnerability_patterns').insertOne(pattern);
    
    this.patterns.set(pattern.patternId, { ...pattern, _id: result.insertedId });
    
    return result.insertedId.toString();
  }

  async updatePattern(patternId: string, updates: Partial<VulnerabilityPattern>): Promise<boolean> {
    const { db } = await connectToDatabase();
    const result = await db.collection<VulnerabilityPattern>('vulnerability_patterns').updateOne(
      { patternId },
      { $set: { ...updates, updatedAt: new Date() } }
    );

    if (result.modifiedCount > 0) {
      const existingPattern = this.patterns.get(patternId);
      if (existingPattern) {
        this.patterns.set(patternId, { ...existingPattern, ...updates });
      }
      return true;
    }

    return false;
  }

  async disablePattern(patternId: string): Promise<boolean> {
    return await this.updatePattern(patternId, { isActive: false });
  }

  async getPatternStats(): Promise<{
    total: number;
    byLanguage: Record<string, number>;
    bySeverity: Record<string, number>;
    byCategory: Record<string, number>;
  }> {
    const patterns = Array.from(this.patterns.values());
    
    const byLanguage: Record<string, number> = {};
    const bySeverity: Record<string, number> = {};
    const byCategory: Record<string, number> = {};

    patterns.forEach(pattern => {
      pattern.language.forEach(lang => {
        byLanguage[lang] = (byLanguage[lang] || 0) + 1;
      });
      
      bySeverity[pattern.severity] = (bySeverity[pattern.severity] || 0) + 1;
      byCategory[pattern.category] = (byCategory[pattern.category] || 0) + 1;
    });

    return {
      total: patterns.length,
      byLanguage,
      bySeverity,
      byCategory
    };
  }

  async searchPatterns(query: {
    language?: string;
    severity?: string;
    category?: string;
    keyword?: string;
  }): Promise<VulnerabilityPattern[]> {
    let patterns = Array.from(this.patterns.values());

    if (query.language) {
      patterns = patterns.filter(p => p.language.includes(query.language!.toLowerCase()));
    }

    if (query.severity) {
      patterns = patterns.filter(p => p.severity === query.severity);
    }

    if (query.category) {
      patterns = patterns.filter(p => p.category === query.category);
    }

    if (query.keyword) {
      const keyword = query.keyword.toLowerCase();
      patterns = patterns.filter(p => 
        p.name.toLowerCase().includes(keyword) ||
        p.description.toLowerCase().includes(keyword)
      );
    }

    return patterns;
  }
}

// Initialize the vulnerability database
export const vulnerabilityDB = VulnerabilityDatabase.getInstance();
